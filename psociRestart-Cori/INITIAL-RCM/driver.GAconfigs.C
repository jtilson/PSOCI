/**************************************************************************************
 * Copyright (c) 2010 RENCI.
 * All rights reserved. This program and the accompanying materials
 * MAY BE available under the terms of the RENCI Open Source License
 * UNC at Chapel Hill which accompanies this distribution, and is available at
 * http://www.renci.org/resources/open-source-software-license

 * New implementation of PSOCI:

 Classes: 

 Description: 
 
 History:

**************************************************************************************/
/**
 *   @file driverTestVector.C
 *
 */
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>

#include <cmath>
// Now start testing for GA
#include <ga++.h>
//#include <GAServices.h>

#include <dra.h>
#define GA_DATA_TYPE C_DBL

//End ga++

#include "PsociTimer.hpp"
#include "PsociVector.hpp"
#include "PsociGArestart.hpp"
#include "PsociDRAservices.hpp"
#include "PsociDRArestart.hpp"
#include "PsociGAbasis.hpp"
#include "PsociConfigs.hpp"
#include "PsociDeterminants.hpp"
#include "PsociGADeterminants.hpp"


// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//
//  Start driver program 
//
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

#define GCOUT if (g_rank==0) cout

int main(int argc, char **argv)
{
  // Set up global MPI fabric
  
  int g_size;
  int g_rank;
  
  // Set up Global Array fabric
  // heap and stack are per-core quantities - for collective operations
  // ALlocate in terms of DOUBLES for now

  const long wordSize = sizeof(double);
  const long OneGigaByte = 128*1024*1024 * wordSize; // A total of 1 Gig but Generally thinking interms of doubles (words)... 
  long maxMemPerCore = OneGigaByte;

  unsigned int heap=9000000, stack=9000000;
  GA::Initialize(argc, argv, heap, stack, GA_DATA_TYPE, 0);
  GA::setMemoryLimit( maxMemPerCore );
  g_size = GA::nodes();
  g_rank = GA::nodeid();
  if ( GA::usesMA() ) cout << "GA memory is coming from MA " << endl;
  if ( GA::usesFAPI() ) cout << "GA is using Fortran indexing " << endl;
  
  GCOUT << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" << endl << endl;
  GCOUT << "Compiled on " << __DATE__ << " at " << __TIME__ << endl;
  GCOUT << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" << endl << endl;
  
  GCOUT << "Parallel GA Run with " << g_size << " Total processors " << endl;
  
  string filename = "configs.test";
  PsociConfigs configs( filename ); //File is opened/closed at the read

  if ( g_rank == 0 ) {
    configs.printFilename();
    if ( configs.readConfigs() != 0 ) {
       cerr << "Failed to read configs at numfgs =" << endl;
       GA::Terminate();
    }
    configs.printParams();
//    configs.printConfigurations();
  }
  configs.brdcstConfigs( 0 ); //now replicated to all nodes

/*
  if ( GA::nodeid() == 0 ) {
     cout << "NODE 0 configs are " << endl;
     configs.printConfigurations();
  }
  GA::sync();

  if ( GA::nodeid() == 1 ) {
     cout << "NODE 1 configs are " << endl;
     configs.printConfigurations();
  }
  GA::sync();

*/

// Okay to here


  if ( g_rank == 0 ) {
  vector<pair<int,string> > word;
  int maxspatials = configs.numTotalSpatials();
  cout << "Num total spatials is " << maxspatials << endl;
  int newsym = configs.fetchConfig( 1, maxspatials, word );
  cout << "new sym and string are " << newsym << endl;
  }

// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


  PsociDeterminants deters( &configs );
  deters.printParams();
  int maxspatials = deters.maxSpatials(); 


// Process the Configs in chunks per processor
  pair<int,double> time;
  
  deters.printFinalDeterminants(); // just a trigger
//fetchConfigs also generates the determinants....

//Note how we can carve up detemrinants apace by simply doing fetch on a subset. Hmm, 
// can we do this iteratively ? Yes so we can do an adaptive procesisng of the space.
// Also config .index is unique for each as that s generated by the PsociConfigs method on read.

  int width = ( maxspatials / g_size ) + 1 ;
  int mylow = (g_rank * width) + 1 ;
  int myhi = min( (g_rank+1)*width , maxspatials );

  cout << GA::nodeid() << " I am fetching " << mylow<< " "<< myhi << endl;
  deters.fetchConfigs( mylow, myhi, time ); //this endsup setting the det index

/*
  if ( g_rank == 0 ) {
  deters.fetchConfigs( 1, maxspatials/2, time ); //fetches into the deters. The plan is to do so data-parallel
  } else {
  deters.fetchConfigs( maxspatials/2+1, maxspatials, time );
  }
*/

  cout << "I am " << time.first << " TIme to fetch cnfigs is " << time.second << endl;
 
/*
  if ( GA::nodeid() == 0 ) {
  for(int i=0; i<maxspatials; ++i ) {
  deters.printSpatialsData( i+1 ); // NOTE: the '1' is a relative index ( per core )
  }
  }
  GA::sync();
*/

  


  cout << "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC" << endl;
  deters.assembleGlobalMaxDetSef();

  cout << "local max ndeti per spatial is " << deters.fetchLocalMaxDetPerSpatial() << endl;
  cout << "global max ndeti per spatial is " << deters.fetchGlobalMaxDetPerSpatial() << endl;

  cout << "Print spin parity is " << deters.fetchSpinParity() << endl;
  deters.assembleGlobalNumSpatials();
  cout << "num spatials readin by PsociConfigs method is " << deters.maxSpatials() << endl;
  cout << "Max num actually processed globally are " << deters.fetchGlobalMaxSpatials() << endl;
  cout << "Max ndet processed globally are " << deters.fetchGlobalMaxDet() << endl;
  cout << "Max nsef processed globally are " << deters.fetchGlobalMaxSef() << endl;
  cout << "Number of LOCAL spatials is " << deters.localSpatials() << endl;
  cout << "Max ndet per spatial processed globally are " << deters.fetchGlobalMaxDetPerSpatial() << endl;

// Start processing the movement of determinant data to GA. Once there, we can teardown all local 
// determinant data structures.

  cout << endl << endl;
  cout << "Build distributed GA_DET space " << endl;
  
  GA::GlobalArray * g_det; // declare global det data
  GA::GlobalArray * g_det_num;
  GA::GlobalArray * g_nsef;

  PsociGADeterminants deters_det( g_det, g_det_num, g_nsef );

  
// Careful here: using this method requires deters to NOT be torn down yet.
// Option 1:
//  cout << "Createdeterminants " << endl;
//  deters_det.createDistributedDeterminants( &deters ); // GA created and all local dets are pushed to GA


// Option 2: The better one
  cout << "Generate determinants " << endl;
  deters_det.generateDistributedDeterminants( configs );

  deters_det.printDistribution();
  deters_det.printDimensions();

//  deters.tearDownDeterminants();// we need these for option 3 testing

  cout << "Can we still work with this AND tear down dets " << maxspatials << endl;

  cout << endl << endl << endl;

// Remember: you can ony print ewhat you own - data parallel style object
  if ( GA::nodeid()==0) {
  JOUTFG fetch;
  for(int i=0; i< maxspatials; ++i ) {
     deters_det.fetchAndUnpackDeterminantData( i+1,fetch );
     cout << "PRINT OUT FETCH " << endl;
     deters_det.printSpatialsData( fetch );
     cout << "END PRTINTOUT FETCH " << endl;
  }
  }
  GA::sync();
  GA::printStats();

/* Option 3 - the method used for the pseudo-direct CI where we simply fetch spatials
   and compute determinants on the fly. This requires a slightly different combination
   of method calls
*/

  GA::GlobalArray * g_det2; // declare global det data
  GA::GlobalArray * g_det_num2;
  GA::GlobalArray * g_nsef2;

  PsociGADeterminants deters_det2( configs, g_det2, g_det_num2, g_nsef2 );

  cout << "Generate on-the-fly determinants " << endl;

  deters_det2.generateDistributedDeterminants();
  deters_det2.destroyLocalDeterminantsData();

  deters_det2.printDistribution();
  deters_det2.printDimensions();

  cout << "Can we still work with this AND tear down dets " << maxspatials << endl;

  cout << endl << endl << endl;

// Remember: you can ony print ewhat you own - data parallel style object

  JOUTFG toutfg;
  cout << (deters_det2.fetchInternalDeters())->fetchGlobalMaxDetPerSpatial()<<endl;
  cout << "CHECK if a spatial prints correctly " << endl;
 deters_det2.fetchInternalDeters()->computeConfigs( 2, toutfg );
 deters_det2.fetchInternalDeters()->printSpatialsData( toutfg );


  GA::sync();
  GA::printStats();

//Generally do not want eveyone print out their arrays.....
//but for now go ahead

  cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX finished XXXXXXXXXXXXXXXXXXX " << endl;
  
  GA::Terminate();
  
}



