/**************************************************************************************
 * Copyright (c) 2010 RENCI.
 * All rights reserved. This program and the accompanying materials
 * MAY BE available under the terms of the RENCI Open Source License
 * UNC at Chapel Hill which accompanies this distribution, and is available at
 * http://www.renci.org/resources/open-source-software-license

 * New implementation of PSOCI:

 Classes: 

 Description: 
 
 History:

**************************************************************************************/
/**
 *   @file driver.hamiltonian.C
 *
 */
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>

#include <cmath>
// Now start testing for GA
#include <ga++.h>

#include <dra.h>
#define GA_DATA_TYPE C_DBL

//End ga++

#include "PsociTimer.hpp"
#include "PsociVector.hpp"
#include "PsociGArestart.hpp"
#include "PsociDRAservices.hpp"
#include "PsociDRArestart.hpp"
#include "PsociGAbasis.hpp"
#include "PsociConfigs.hpp"
#include "PsociDeterminants.hpp"
#include "PsociGADeterminants.hpp"
#include "PsociHamiltonian.hpp"


// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//
//  Start driver program 
//
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

#define GCOUT if (g_rank==0) cout

int main(int argc, char **argv)
{
  // Set up global MPI fabric
  
  int g_size;
  int g_rank;
  
  // Set up Global Array fabric
  // heap and stack are per-core quantities - for collective operations
  // ALlocate in terms of DOUBLES for now

  const long wordSize = sizeof(double);
  const long OneGigaByte = 128*1024*1024 * wordSize; // A total of 1 Gig but Generally thinking interms of doubles (words)... 
  long maxMemPerCore = OneGigaByte;

  unsigned int heap=9000000, stack=9000000;
  GA::Initialize(argc, argv, heap, stack, GA_DATA_TYPE, 0);
  GA::setMemoryLimit( maxMemPerCore );
  g_size = GA::nodes();
  g_rank = GA::nodeid();
  if ( GA::usesMA() ) cout << "GA memory is coming from MA " << endl;
  if ( GA::usesFAPI() ) cout << "GA is using Fortran indexing " << endl;
  
  GCOUT << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" << endl << endl;
  GCOUT << "Compiled on " << __DATE__ << " at " << __TIME__ << endl;
  GCOUT << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" << endl << endl;
  
  GCOUT << "Parallel GA Run with " << g_size << " Total processors " << endl;
  
  string filename = "configs.test";
  PsociConfigs configs( filename ); //File is opened/closed at the read

  if ( g_rank == 0 ) {
    configs.printFilename();
    if ( configs.readConfigs() != 0 ) {
       cerr << "Failed to read configs at numfgs =" << endl;
       GA::Terminate();
    }
    configs.printParams();
    configs.printConfigurations();
  }

  
  configs.brdcstConfigs( 0 ); //now replicated to all nodes

  if ( g_rank == 0 ) {
  vector<pair<int,string> > word;
  int maxspatials = configs.numTotalSpatials();
  cout << "Num total spatials is " << maxspatials << endl;
  int newsym = configs.fetchConfig( 1, maxspatials, word );
  cout << "new sym and string are " << newsym << endl;
  }

// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


  PsociDeterminants deters( &configs );
  deters.printParams();
  int maxspatials = deters.maxSpatials(); 


// Process the Configs in chunks per processor
  pair<int,double> time;
  
  deters.printFinalDeterminants(); // just a trigger
//fetchConfigs also generates the determinants....

//Note how we can carve up detemrinants apace by simply doing fetch on a subset. Hmm, 
// can we do this iteratively ? Yes so we can do an adaptive procesisng of the space.
// Also config .index is unique for each as that s generated by the PsociConfigs method on read.

  int width = ( maxspatials +1 ) / g_size ;
  int mylow = g_rank * width;
  int myhi = min( mylow + width , maxspatials );

   deters.fetchConfigs( mylow+1, myhi, time );

  //deters.fetchConfigs( 1, maxspatials,  time );

  cout << "I am " << time.first << " TIme to fetch cnfigs is " << time.second << endl;
 
  deters.printSpatialsData( 1 ); // NOTE: the '1' is a relative index ( per core )

  int testconf=maxspatials;
  //deters.printSpatialsData( testconf );

  deters.assembleGlobalMaxDetSef();

  cout << "local max ndeti per spatial is " << deters.fetchLocalMaxDetPerSpatial() << endl;
  cout << "global max ndeti per spatial is " << deters.fetchGlobalMaxDetPerSpatial() << endl;

  cout << "Print spin parity is " << deters.fetchSpinParity() << endl;
  deters.assembleGlobalNumSpatials();
  cout << "num spatials readin by PsociConfigs method is " << deters.maxSpatials() << endl;
  cout << "Max num actually processed globally are " << deters.fetchGlobalMaxSpatials() << endl;
  cout << "Max ndet processed globally are " << deters.fetchGlobalMaxDet() << endl;
  cout << "Max nsef processed globally are " << deters.fetchGlobalMaxSef() << endl;
  cout << "Number of LOCAL spatials is " << deters.localSpatials() << endl;
  cout << "Max ndet per spatial processed globally are " << deters.fetchGlobalMaxDetPerSpatial() << endl;
  cout << "Max nsef per spatial processed globally are " << deters.fetchGlobalMaxSefPerSpatial() << endl;

   deters.assembleGlobalJobParameters(); // more assdembly 

  int ksym = deters.fetchGlobalSymmetry();
  cout << "FETCHED global sym is " << ksym << endl;


// Start processing the movement of determinant data to GA. Once there, we can teardown all local 
// determinant data structures.

  cout << endl << endl;
  cout << "Build distributed GA_DET space " << endl;
  
  GA::GlobalArray * g_det; // declare global det data
  GA::GlobalArray * g_det_num;
  GA::GlobalArray * g_nsef;

  PsociGADeterminants deters_det( g_det, g_det_num, g_nsef ); 

  deters_det.createDistributedDeterminants( &deters ); // GA created and all local dets are pushed to GA
  deters_det.printDistribution();


cout << "Neec after tear down is " << deters_det.fetchNumElectrons() << endl;
//OPen up buffer space for fetching Dets data
  vector<JOUTFG> fetch;
  vector<int> grab;

  pair<int,double> info;

  deters_det.assembleDimensions();
  deters_det.printDimensions();

  vector<int> l_nsef;
  deters_det.assembleAndBrdcstNsef( l_nsef );

  cout << "GLobal l_nsef " << l_nsef.size() << endl;
  for(int i=0; i<deters.fetchGlobalMaxSpatials(); ++i ) {
     cout << " " << l_nsef[i];
  }
  cout << endl; 













  cout << "Can we still work with this AND tear down dets " << endl;

  int nbf = deters.fetchNumBasisFunctions();
  int nelec = deters.fetchNumElectrons();

 //  cout << "Neec after tear down is " << deters.fetchNumElectrons() << endl;
   cout << "NBF is " << deters.fetchNumBasisFunctions() << endl;

  fetch.clear();
  for(int i=0; i< testconf; ++i) {
    grab.push_back(i+1);
  }
  cout << "Nukbert of requested fetches is " << grab.size() << endl;

//THis works because I haven;t tornDown the dets yet.
   cout << "BEFORE GA: Can I print out the data for a single fetched det ? " << endl;
   vector<int>::iterator git;
   for(git=grab.begin(); git != grab.end(); ++git ) {
   deters.printSpatialsData( (*git) );
   }


  deters_det.fetchAndUnpackDeterminantData( grab, info, fetch  ); 

   cout << "AFTER GA: Can I print out the data for a single fetched det ? " << endl;
   vector<JOUTFG>::iterator jit;
   for(jit=fetch.begin(); jit != fetch.end(); ++jit ) {
   deters.printSpatialsData( (*jit) );
   }


 cout << "I am " << GA::nodeid() << " Time to fetch deters is " << info.second << endl;
 cout << "I am " << GA::nodeid() << " Size of fetched data is " << fetch.size() << endl;


/* Must open up integrals */

   string filername="./INTEGRALS/RUO32BIT/moints";
   Fint l_unit = 2;
   PsociIntegrals mos( 0, l_unit, filername );
   mos.printFilename();
   Fint unit = mos.fetchUnit();
   mos.OpenFile();

   if ( mos.sifrh1() != 0 ) {
     cerr << "sifrh1 not zero value aborting: " << endl;
     cerr << "probably incompatible 32bit/64bit builds " << endl;
     GA::Terminate();
     exit(1);
   }

   mos.printSifrh1();
   cout << endl << endl;

   int status = mos.sifrh2();
   mos.printSifrh2();

   status = mos.fetchOneElectronInts();
   mos.set1ePrint();
   mos.printOneElectronInts();
   int stat = mos.brdcstOneElectronInts();

   mos.fetchTwoElectronInts();
   int statb = mos.brdcstTwoElectronInts();

//   mos.set2ePrint();
   mos.printTwoElectronInts();

/* end of integrals */

//Need to process many groups now for better debugging.....
// Do fetch[0] against all others

  PsociHamiltonian hamilton( deters_det.fetchNumBasisFunctions(), deters_det.fetchNumElectrons() );
  hamilton.specifyIntegrals( &mos );

//generateSOCIblocks compute all contributions fore configs I and J returning that in sefsef.
// ultimztel should return sefsef from which it will be stoired to DRA.


  hamilton.setKsym( ksym );
  hamilton.setPerSpatialValues(deters_det.fetchGlobalMaxDetPerSpatial(), deters_det.fetchGlobalMaxSefPerSpatial()); //maynot work after teardown

  vector<double> sefsef;
  for(int i=0; i< fetch.size(); ++i) {
     for(int j=0; j< i; ++j ) {
     cout << "XXXXXXXXXXXXXXXXXX NEXT PAIR XXXX " << endl;
     cout << " Pair are i and j = " << i+1 << " " << j+1 << endl;
     hamilton.generateSOCIblocks( fetch[j], fetch[i], sefsef );
     }
  }

/* For testing DIagonal terms we need to do something differenet.
*/

  sefsef.clear();
  for(int i=0; i< fetch.size(); ++i) {
     cout << "XXXXXXXXXXXXXXXXXX NEXT DIAG PAIR XXXX " << endl;
     cout << " Pair are i and j = " << i+1 << " " << i+1 << endl;
     hamilton.generateSOCIblocks( fetch[i], fetch[i], sefsef );
  }


// Test causing a failure .....

/*
   vnt.clear();
     for(int i=0; i< fetch.size(); ++i) {
     cout << "XXXXXXXXXXXXXXXXXX DIAG TERMS XXXX " << endl;
     cout << " i= " << i << endl;
     hamilton.generateExcitationBlocks( fetch[i], fetch[i], vnt );
  }
*/

/*
   cout << "Should cause a hard failure " << endl;
   hamilton.generateOffdiagExcitationBlocks( fetch[0], fetch[0] );
*/
  
  int mxdet = deters_det.fetchGlobalMaxDetPerSpatial();
  int mxsef = deters_det.fetchGlobalMaxSefPerSpatial();
 
  hamilton.setPerSpatialValues( mxdet, mxsef );
  hamilton.setKsym( deters_det.fetchGlobalSymmetry() );
  hamilton.printKsym();
  hamilton.printPerSpatialValues();


     
    
// cout << "Try some Hamiltonian processing compare ioutfg 1 and 2" << endl;
//   PsociHamiltonian hamilton( nbf, nelec );
//   int sum = hamilton.generateExcitationBlocks( fetch[0], fetch[1] );

  cout << "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX finished XXXXXXXXXXXXXXXXXXX " << endl;
  
  GA::Terminate();
  
}



